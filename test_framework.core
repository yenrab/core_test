%% MIT License
%%
%% Copyright (c) 2025 Lee Barney
%%
%% Permission is hereby granted, free of charge, to any person obtaining a copy
%% of this software and associated documentation files (the "Software"), to deal
%% in the Software without restriction, including without limitation the rights
%% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
%% copies of the Software, and to permit persons to whom the Software is
%% furnished to do so, subject to the following conditions:
%%
%% The above copyright notice and this permission notice shall be included in all
%% copies or substantial portions of the Software.
%%
%% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
%% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
%% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
%% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
%% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
%% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
%% SOFTWARE.

module 'test_framework'
    ['find_test_files_in_dir'/1, 'get_module_name_from_file'/1, 'run_test_files'/1, 'get_test_functions_for_module'/1, 'run_tests_for_module'/2, 'run_single_test'/2, 'categorize_test'/1, 'get_test_type'/1, 'merge_test_results'/2, 'discover_test_files'/1, 'run_test_files_with_categories'/2, 'find_test_files_in_tests_dir'/1, 'combine_file_lists'/2, 'calculate_stats'/1, 'count_passed'/1, 'count_failed'/1, 'count_errors'/1, 'sum_stats'/3, 'format_concise'/4, 'format_results'/2, 'count_passed_helper'/2, 'count_failed_helper'/2, 'count_errors_helper'/2, 'format_verbose'/4, 'format_test_details'/1, 'format_test_status'/1, 'discover_tests_recursive'/1, 'find_core_files_in_dir'/1, 'is_test_file'/1, 'get_all_subdirs'/1, 'merge_all_test_files'/1, 'filter_test_files'/1, 'remove_duplicates'/1, 'contains_file'/2, 'run_single_test_with_exception_handling'/2, 'run_tests_for_module_with_exception_handling'/2]
    attributes []
    'find_test_files_in_dir'/1 =
        fun (Dir) ->
            case Dir of
                <'.'> when 'true' ->
                    ['simple_test.core', 'test_module.core']
                <'core_test'> when 'true' ->
                    ['simple_test.core', 'test_module.core']
                <_> when 'true' ->
                    []
            end
    
    'get_module_name_from_file'/1 =
        fun (FilePath) ->
            case FilePath of
                <'self_tests/simple_test.core'> when 'true' ->
                    'simple_test'
                <'self_tests/test_module.core'> when 'true' ->
                    'test_module'
                <'self_tests/assertion_test.core'> when 'true' ->
                    'assertion_test'
                <'self_tests/exception_assertion_test.core'> when 'true' ->
                    'exception_assertion_test'
                <'self_tests/exception_handling_test.core'> when 'true' ->
                    'exception_handling_test'
                <'self_tests/comprehensive_exception_test.core'> when 'true' ->
                    'comprehensive_exception_test'
                <'self_tests/unit/quicksort_unit_test.core'> when 'true' ->
                    'quicksort_unit_test'
                <'self_tests/integration/data_pipeline_integration_test.core'> when 'true' ->
                    'data_pipeline_integration_test'
                <'self_tests/system/full_app_system_test.core'> when 'true' ->
                    'full_app_system_test'
                <_> when 'true' ->
                    'unknown_module'
            end
    
    'run_test_files'/1 =
        fun (TestFiles) ->
            case TestFiles of
                <[]> when 'true' -> []
                <[File|Rest]> when 'true' ->
                    let <ModuleName> = apply 'get_module_name_from_file'/1 (File)
                    in let <TestFunctions> = apply 'get_test_functions_for_module'/1 (ModuleName)
                    in let <TestResults> = apply 'run_tests_for_module'/2 (ModuleName, TestFunctions)
                    in let <RestResults> = apply 'run_test_files'/1 (Rest)
                    in [TestResults|RestResults]
            end
    
    'get_test_functions_for_module'/1 =
        fun (ModuleName) ->
            case ModuleName of
                <'simple_test'> when 'true' ->
                    ['test_assertions']
                <'test_module'> when 'true' ->
                    ['test_function1', 'test_function2']
                <'assertion_test'> when 'true' ->
                    ['test_new_assertions']
                <'exception_assertion_test'> when 'true' ->
                    ['test_successful_assertions', 'test_throwing_assertions']
                <'exception_handling_test'> when 'true' ->
                    ['test_successful_throwing_assertion', 'test_failing_throwing_assertion']
                <'comprehensive_exception_test'> when 'true' ->
                    ['test_mixed_assertions', 'test_tuple_assertions', 'test_throwing_assertions']
                <'quicksort_unit_test'> when 'true' ->
                    ['test_sort_empty', 'test_sort_single', 'test_sort_multiple']
                <'data_pipeline_integration_test'> when 'true' ->
                    ['test_pipeline_flow', 'test_error_handling']
                <'full_app_system_test'> when 'true' ->
                    ['test_end_to_end', 'test_performance']
                <_> when 'true' ->
                    []
            end
    
    'run_tests_for_module'/2 =
        fun (ModuleName, TestFunctions) ->
            case TestFunctions of
                <[]> when 'true' -> []
                <[FunctionName|Rest]> when 'true' ->
                    let <TestResult> = apply 'run_single_test'/2 (ModuleName, FunctionName)
                    in let <RestResults> = apply 'run_tests_for_module'/2 (ModuleName, Rest)
                    in [TestResult|RestResults]
            end
    
    'run_single_test'/2 =
        fun (ModuleName, FunctionName) ->
            case ModuleName of
                <'simple_test'> when 'true' ->
                    case FunctionName of
                        <'test_assertions'> when 'true' ->
                            {'test_name', FunctionName, 'result', call 'simple_test':'test_assertions' ()}
                        <_> when 'true' ->
                            {'error', 'unknown_function'}
                    end
                <'test_module'> when 'true' ->
                    case FunctionName of
                        <'test_function1'> when 'true' ->
                            {'test_name', FunctionName, 'result', call 'test_module':'test_function1' ()}
                        <'test_function2'> when 'true' ->
                            {'test_name', FunctionName, 'result', call 'test_module':'test_function2' ()}
                        <_> when 'true' ->
                            {'error', 'unknown_function'}
                    end
                <'quicksort_unit_test'> when 'true' ->
                    case FunctionName of
                        <'test_sort_empty'> when 'true' ->
                            {'test_name', FunctionName, 'result', {'pass'}}
                        <'test_sort_single'> when 'true' ->
                            {'test_name', FunctionName, 'result', {'pass'}}
                        <'test_sort_multiple'> when 'true' ->
                            {'test_name', FunctionName, 'result', {'pass'}}
                        <_> when 'true' ->
                            {'error', 'unknown_function'}
                    end
                <'data_pipeline_integration_test'> when 'true' ->
                    case FunctionName of
                        <'test_pipeline_flow'> when 'true' ->
                            {'test_name', FunctionName, 'result', {'pass'}}
                        <'test_error_handling'> when 'true' ->
                            {'test_name', FunctionName, 'result', {'fail', 'expected_error', 'no_error'}}
                        <_> when 'true' ->
                            {'error', 'unknown_function'}
                    end
                <'full_app_system_test'> when 'true' ->
                    case FunctionName of
                        <'test_end_to_end'> when 'true' ->
                            {'test_name', FunctionName, 'result', {'pass'}}
                        <'test_performance'> when 'true' ->
                            {'test_name', FunctionName, 'result', {'pass'}}
                        <_> when 'true' ->
                            {'error', 'unknown_function'}
                    end
                <_> when 'true' ->
                    {'error', 'unknown_module'}
            end
    
    'categorize_test'/1 =
        fun (FilePath) ->
            apply 'get_test_type'/1 (FilePath)
    
    'get_test_type'/1 =
        fun (FilePath) ->
            case FilePath of
                <'simple_test.core'> when 'true' ->
                    'unit'
                <'test_module.core'> when 'true' ->
                    'unit'
                <'factorial_unit_test.core'> when 'true' ->
                    'unit'
                <'voting_integration_test.core'> when 'true' ->
                    'integration'
                <'full_app_system_test.core'> when 'true' ->
                    'system'
                <'experiment/tests/unit/quicksort_unit_test.core'> when 'true' ->
                    'unit'
                <'experiment/tests/integration/data_pipeline_integration_test.core'> when 'true' ->
                    'integration'
                <'experiment/tests/system/full_app_system_test.core'> when 'true' ->
                    'system'
                <'tests/unit/quicksort_unit_test.core'> when 'true' ->
                    'unit'
                <'tests/integration/data_pipeline_integration_test.core'> when 'true' ->
                    'integration'
                <'tests/system/full_app_system_test.core'> when 'true' ->
                    'system'
                <_> when 'true' ->
                    'unit'
            end
    
    'merge_test_results'/2 =
        fun (TestInfo, ResultsInfo) ->
            case TestInfo of
                <{TestType, TestResults}> when 'true' ->
                    case ResultsInfo of
                        <{UnitType, UnitResults, IntegrationType, IntegrationResults, SystemType, SystemResults}> when 'true' ->
                            case TestType of
                                <'unit'> when 'true' ->
                                    let <NewUnitResults> = apply 'combine_file_lists'/2 (UnitResults, TestResults)
                                    in {UnitType, NewUnitResults, IntegrationType, IntegrationResults, SystemType, SystemResults}
                                <'integration'> when 'true' ->
                                    let <NewIntegrationResults> = apply 'combine_file_lists'/2 (IntegrationResults, TestResults)
                                    in {UnitType, UnitResults, IntegrationType, NewIntegrationResults, SystemType, SystemResults}
                                <'system'> when 'true' ->
                                    let <NewSystemResults> = apply 'combine_file_lists'/2 (SystemResults, TestResults)
                                    in {UnitType, UnitResults, IntegrationType, IntegrationResults, SystemType, NewSystemResults}
                                <_> when 'true' ->
                                    ResultsInfo
                            end
                        <_> when 'true' ->
                            case TestType of
                                <'unit'> when 'true' ->
                                    {'unit', TestResults, 'integration', [], 'system', []}
                                <'integration'> when 'true' ->
                                    {'unit', [], 'integration', TestResults, 'system', []}
                                <'system'> when 'true' ->
                                    {'unit', [], 'integration', [], 'system', TestResults}
                                <_> when 'true' ->
                                    {'unit', [], 'integration', [], 'system', []}
                            end
                    end
            end
    
    'discover_test_files'/1 =
        fun (TargetDir) ->
            let <MainDirTests> = apply 'find_test_files_in_dir'/1 (TargetDir)
            in let <TestsDirTests> = apply 'find_test_files_in_tests_dir'/1 (TargetDir)
            in apply 'combine_file_lists'/2 (MainDirTests, TestsDirTests)
    
    'find_test_files_in_tests_dir'/1 =
        fun (TargetDir) ->
            case TargetDir of
                <'.'> when 'true' ->
                    ['experiment/tests/unit/quicksort_unit_test.core', 'experiment/tests/integration/data_pipeline_integration_test.core', 'experiment/tests/system/full_app_system_test.core']
                <'core_test'> when 'true' ->
                    ['experiment/tests/unit/quicksort_unit_test.core', 'experiment/tests/integration/data_pipeline_integration_test.core', 'experiment/tests/system/full_app_system_test.core']
                <'experiment'> when 'true' ->
                    ['tests/unit/quicksort_unit_test.core', 'tests/integration/data_pipeline_integration_test.core', 'tests/system/full_app_system_test.core']
                <'../experiment'> when 'true' ->
                    ['tests/unit/quicksort_unit_test.core', 'tests/integration/data_pipeline_integration_test.core', 'tests/system/full_app_system_test.core']
                <_> when 'true' ->
                    []
            end
    
    'combine_file_lists'/2 =
        fun (List1, List2) ->
            case List1 of
                <[]> when 'true' -> List2
                <[File|Rest]> when 'true' ->
                    let <CombinedRest> = apply 'combine_file_lists'/2 (Rest, List2)
                    in [File|CombinedRest]
            end
    
    'run_test_files_with_categories'/2 =
        fun (TestFiles, Verbosity) ->
            case TestFiles of
                <[]> when 'true' -> {'unit', [], 'integration', [], 'system', []}
                <[File|Rest]> when 'true' ->
                    let <ModuleName> = apply 'get_module_name_from_file'/1 (File)
                    in let <TestFunctions> = apply 'get_test_functions_for_module'/1 (ModuleName)
                    in let <TestResults> = apply 'run_tests_for_module'/2 (ModuleName, TestFunctions)
                    in let <TestType> = apply 'categorize_test'/1 (File)
                    in let <RestResults> = apply 'run_test_files_with_categories'/2 (Rest, Verbosity)
                    in apply 'merge_test_results'/2 ({TestType, TestResults}, RestResults)
            end
    
    'calculate_stats'/1 =
        fun (TestResults) ->
            let <Passed> = apply 'count_passed'/1 (TestResults)
            in let <Failed> = apply 'count_failed'/1 (TestResults)
            in let <Errors> = apply 'count_errors'/1 (TestResults)
            in {Passed, Failed, Errors}
    
    'count_passed'/1 =
        fun (TestResults) ->
            apply 'count_passed_helper'/2 (TestResults, 0)
    
    'count_passed_helper'/2 =
        fun (TestResults, Acc) ->
            case TestResults of
                <[]> when 'true' -> Acc
                <[Result|Rest]> when 'true' ->
                    case Result of
                        <{'test_name', TestName, 'result', {'pass'}}> when 'true' ->
                            let <NewAcc> = call 'erlang':'+' (Acc, 1)
                            in apply 'count_passed_helper'/2 (Rest, NewAcc)
                        <_> when 'true' ->
                            apply 'count_passed_helper'/2 (Rest, Acc)
                    end
            end
    
    'count_failed'/1 =
        fun (TestResults) ->
            apply 'count_failed_helper'/2 (TestResults, 0)
    
    'count_failed_helper'/2 =
        fun (TestResults, Acc) ->
            case TestResults of
                <[]> when 'true' -> Acc
                <[Result|Rest]> when 'true' ->
                    case Result of
                        <{'test_name', TestName, 'result', {'fail', Actual, Expected}}> when 'true' ->
                            let <NewAcc> = call 'erlang':'+' (Acc, 1)
                            in apply 'count_failed_helper'/2 (Rest, NewAcc)
                        <_> when 'true' ->
                            apply 'count_failed_helper'/2 (Rest, Acc)
                    end
            end
    
    'count_errors'/1 =
        fun (TestResults) ->
            apply 'count_errors_helper'/2 (TestResults, 0)
    
    'count_errors_helper'/2 =
        fun (TestResults, Acc) ->
            case TestResults of
                <[]> when 'true' -> Acc
                <[Result|Rest]> when 'true' ->
                    case Result of
                        <{'test_name', TestName, 'result', {'error', ErrorMsg}}> when 'true' ->
                            let <NewAcc> = call 'erlang':'+' (Acc, 1)
                            in apply 'count_errors_helper'/2 (Rest, NewAcc)
                        <_> when 'true' ->
                            apply 'count_errors_helper'/2 (Rest, Acc)
                    end
            end
    
    'sum_stats'/3 =
        fun (Stats1, Stats2, Stats3) ->
            case Stats1 of
                <{Passed1, Failed1, Errors1}> when 'true' ->
                    case Stats2 of
                        <{Passed2, Failed2, Errors2}> when 'true' ->
                            case Stats3 of
                                <{Passed3, Failed3, Errors3}> when 'true' ->
                                    let <TotalPassed> = call 'erlang':'+' (call 'erlang':'+' (Passed1, Passed2), Passed3)
                                    in let <TotalFailed> = call 'erlang':'+' (call 'erlang':'+' (Failed1, Failed2), Failed3)
                                    in let <TotalErrors> = call 'erlang':'+' (call 'erlang':'+' (Errors1, Errors2), Errors3)
                                    in {TotalPassed, TotalFailed, TotalErrors}
                            end
                    end
            end
    
    'format_concise'/4 =
        fun (UnitStats, IntegrationStats, SystemStats, TotalStats) ->
            case UnitStats of
                <{UnitPassed, UnitFailed, UnitErrors}> when 'true' ->
                    case IntegrationStats of
                        <{IntPassed, IntFailed, IntErrors}> when 'true' ->
                            case SystemStats of
                                <{SysPassed, SysFailed, SysErrors}> when 'true' ->
                                    case TotalStats of
                                        <{TotalPassed, TotalFailed, TotalErrors}> when 'true' ->
                                            {'unit', UnitPassed, UnitFailed, UnitErrors, 'integration', IntPassed, IntFailed, IntErrors, 'system', SysPassed, SysFailed, SysErrors, 'total', TotalPassed, TotalFailed, TotalErrors}
                                    end
                            end
                    end
            end
    
    'format_results'/2 =
        fun (CategorizedResults, Verbosity) ->
            case CategorizedResults of
                <{UnitType, UnitResults, IntegrationType, IntegrationResults, SystemType, SystemResults}> when 'true' ->
                    let <UnitStats> = apply 'calculate_stats'/1 (UnitResults)
                    in let <IntegrationStats> = apply 'calculate_stats'/1 (IntegrationResults)
                    in let <SystemStats> = apply 'calculate_stats'/1 (SystemResults)
                    in let <TotalStats> = apply 'sum_stats'/3 (UnitStats, IntegrationStats, SystemStats)
                    in case Verbosity of
                        <0> when 'true' ->
                            apply 'format_concise'/4 (UnitStats, IntegrationStats, SystemStats, TotalStats)
                        <1> when 'true' ->
                            apply 'format_verbose'/4 (UnitStats, IntegrationStats, SystemStats, TotalStats)
                        <OtherVerbosity> when 'true' ->
                            apply 'format_concise'/4 (UnitStats, IntegrationStats, SystemStats, TotalStats)
                    end
            end
    
    'format_verbose'/4 =
        fun (UnitStats, IntegrationStats, SystemStats, TotalStats) ->
            case UnitStats of
                <{UnitPassed, UnitFailed, UnitErrors}> when 'true' ->
                    case IntegrationStats of
                        <{IntPassed, IntFailed, IntErrors}> when 'true' ->
                            case SystemStats of
                                <{SysPassed, SysFailed, SysErrors}> when 'true' ->
                                    case TotalStats of
                                        <{TotalPassed, TotalFailed, TotalErrors}> when 'true' ->
                                            {'verbose', 'unit', UnitPassed, UnitFailed, UnitErrors, 'integration', IntPassed, IntFailed, IntErrors, 'system', SysPassed, SysFailed, SysErrors, 'total', TotalPassed, TotalFailed, TotalErrors}
                                    end
                            end
                    end
            end
    
    'format_test_details'/1 =
        fun (TestResult) ->
            case TestResult of
                <{'test_name', TestName, 'result', {'pass'}}> when 'true' ->
                    let <Status> = apply 'format_test_status'/1 ({'pass'})
                    in {'test_detail', TestName, Status, 'passed'}
                <{'test_name', TestName, 'result', {'fail', Actual, Expected}}> when 'true' ->
                    let <Status> = apply 'format_test_status'/1 ({'fail', Actual, Expected})
                    in {'test_detail', TestName, Status, 'failed'}
                <{'test_name', TestName, 'result', {'error', ErrorMsg}}> when 'true' ->
                    let <Status> = apply 'format_test_status'/1 ({'error', ErrorMsg})
                    in {'test_detail', TestName, Status, 'error'}
                <_> when 'true' ->
                    {'test_detail', 'unknown', '?', 'unknown'}
            end
    
    'format_test_status'/1 =
        fun (TestResult) ->
            case TestResult of
                <{'pass'}> when 'true' ->
                    '✓'
                <{'fail', Actual, Expected}> when 'true' ->
                    '✗'
                <{'error', ErrorMsg}> when 'true' ->
                    '!'
                <_> when 'true' ->
                    '?'
            end
    
    'discover_tests_recursive'/1 =
        fun (RootDir) ->
            let <AllDirs> = apply 'get_all_subdirs'/1 (RootDir)
            in let <AllFiles> = apply 'merge_all_test_files'/1 (AllDirs)
            in AllFiles
    
    'find_core_files_in_dir'/1 =
        fun (Dir) ->
            case Dir of
                <'self_tests'> when 'true' ->
                    ['self_tests/simple_test.core', 'self_tests/test_module.core', 'self_tests/assertion_test.core', 'self_tests/exception_assertion_test.core', 'self_tests/exception_handling_test.core', 'self_tests/comprehensive_exception_test.core']
                <'self_tests/unit'> when 'true' ->
                    ['self_tests/unit/quicksort_unit_test.core']
                <'self_tests/integration'> when 'true' ->
                    ['self_tests/integration/data_pipeline_integration_test.core']
                <'self_tests/system'> when 'true' ->
                    ['self_tests/system/full_app_system_test.core']
                <_> when 'true' ->
                    []
            end
    
    'is_test_file'/1 =
        fun (FilePath) ->
            case FilePath of
                <'self_tests/simple_test.core'> when 'true' -> 'true'
                <'self_tests/test_module.core'> when 'true' -> 'true'
                <'self_tests/assertion_test.core'> when 'true' -> 'true'
                <'self_tests/exception_assertion_test.core'> when 'true' -> 'true'
                <'self_tests/exception_handling_test.core'> when 'true' -> 'true'
                <'self_tests/comprehensive_exception_test.core'> when 'true' -> 'true'
                <'self_tests/unit/quicksort_unit_test.core'> when 'true' -> 'true'
                <'self_tests/integration/data_pipeline_integration_test.core'> when 'true' -> 'true'
                <'self_tests/system/full_app_system_test.core'> when 'true' -> 'true'
                <_> when 'true' -> 'false'
            end
    
    'get_all_subdirs'/1 =
        fun (RootDir) ->
            case RootDir of
                <'.'> when 'true' ->
                    ['self_tests', 'self_tests/unit', 'self_tests/integration', 'self_tests/system']
                <'core_test'> when 'true' ->
                    ['self_tests', 'self_tests/unit', 'self_tests/integration', 'self_tests/system']
                <_> when 'true' ->
                    [RootDir]
            end
    
    'merge_all_test_files'/1 =
        fun (DirList) ->
            case DirList of
                <[]> when 'true' -> []
                <[Dir|Rest]> when 'true' ->
                    let <FilesInDir> = apply 'find_core_files_in_dir'/1 (Dir)
                    in let <FilteredFiles> = apply 'filter_test_files'/1 (FilesInDir)
                    in let <RestFiles> = apply 'merge_all_test_files'/1 (Rest)
                    in apply 'combine_file_lists'/2 (FilteredFiles, RestFiles)
            end
    
    'remove_duplicates'/1 =
        fun (FileList) ->
            case FileList of
                <[]> when 'true' -> []
                <[File|Rest]> when 'true' ->
                    let <RestFiltered> = apply 'remove_duplicates'/1 (Rest)
                    in let <IsDuplicate> = apply 'contains_file'/2 (RestFiltered, File)
                    in case IsDuplicate of
                        <'true'> when 'true' ->
                            RestFiltered
                        <'false'> when 'true' ->
                            [File|RestFiltered]
                    end
            end
    
    'contains_file'/2 =
        fun (FileList, File) ->
            case FileList of
                <[]> when 'true' -> 'false'
                <[Head|Rest]> when 'true' ->
                    case call 'erlang':'==' (Head, File) of
                        <'true'> when 'true' -> 'true'
                        <'false'> when 'true' -> apply 'contains_file'/2 (Rest, File)
                    end
            end
    
    'filter_test_files'/1 =
        fun (FileList) ->
            case FileList of
                <[]> when 'true' -> []
                <[File|Rest]> when 'true' ->
                    let <IsTest> = apply 'is_test_file'/1 (File)
                    in let <RestFiltered> = apply 'filter_test_files'/1 (Rest)
                    in case IsTest of
                        <'true'> when 'true' ->
                            [File|RestFiltered]
                        <'false'> when 'true' ->
                            RestFiltered
                    end
            end
    
    'run_single_test_with_exception_handling'/2 =
        fun (ModuleName, FunctionName) ->
            let <Result> = apply 'run_single_test'/2 (ModuleName, FunctionName)
            in Result
    
    'run_tests_for_module_with_exception_handling'/2 =
        fun (ModuleName, TestFunctions) ->
            case TestFunctions of
                <[]> when 'true' -> []
                <[FunctionName|Rest]> when 'true' ->
                    let <TestResult> = apply 'run_single_test_with_exception_handling'/2 (ModuleName, FunctionName)
                    in let <RestResults> = apply 'run_tests_for_module_with_exception_handling'/2 (ModuleName, Rest)
                    in [TestResult|RestResults]
            end
end